---
title: "exp1"
format: html
editor: visual
---

### Load packages

```{r}
# List of packages
packages <- c("corrr", "ggplot2", "lme4", "lmerTest", "FactoMineR", "grid","png","cowplot","magick", "ggimage","dplyr","tidyverse","knitr")


```

```{r}

install_and_load_packages <- function(packages) {
  for(package in packages) {
    if(!require(package, character.only = TRUE)) {
      install.packages(package, dependencies = TRUE)
      library(package, character.only = TRUE)
    }
  }
}

# Call the function with the list of packages
install_and_load_packages(packages)

```

```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

```

## Set working directories

```{r}
current_dir<- getwd()

data_dir <-paste0(current_dir,'/../data/')
data_files <-list.files(path = data_dir, full.names = TRUE, pattern="*.csv")
print(paste0('we have data from ',length(data_files),' participants'))



```

## Load in data and filter our texture ids

```{r}

df_list <- lapply(data_files, read.csv)

experiment_data_raw<- bind_rows(df_list)
ratings_trials<- experiment_data_raw %>% filter(trial_type== 'html-slider-response')
ratings_trials_exp<- ratings_trials %>% filter(practiceTrial != 'true')

ratings_trials_exp$response<- as.numeric(ratings_trials_exp$response)
ratings_trials_exp$response<- (ratings_trials_exp$response + 200)/400



extract_texture_id<-function(filename){
  f<- str_split_i(filename,"/",2)
  f<- str_split_i(f,".png",1)
  return(f)
  
}

ratings_trials_exp$texture <- lapply(ratings_trials_exp$texture_id,extract_texture_id)


unique_sona_ids <- unique(ratings_trials_exp$sona_id)
cat(paste(unique_sona_ids, collapse = ", "))
```

```{r}
t<-ratings_trials_exp %>%
  group_by(condition_num) %>%
  summarise(unique_subjects = n_distinct(subject_id))

concept_groups <- ratings_trials_exp %>% 
  select(concept, condition_num) %>% 
  distinct() %>% 
  arrange(condition_num)
```

## Group and pivot into a concept x texture matrix

```{r}
ratings_trial_grouped <- ratings_trials_exp %>% group_by(texture, concept) %>%summarise(mean_rating = mean(response)) 


ratings_trials_grouped_wide<-ratings_trial_grouped %>%
  pivot_wider(names_from = texture, values_from = mean_rating)

ratings_trials_grouped_wide
```

```{r}
### compute matrix rank
SVD <- svd(ratings_trials_grouped_wide[,2:ncol(ratings_trials_grouped_wide)])$d > 1e-10
mat_rank <- sum(SVD)
print(mat_rank)
```

```{r}


bootstrap_associations_matrices<- function(ratings_df, sample_size){
  
  group1ids<- ratings_df %>%
  group_by(condition_num) %>%
  sample_n(sample_size,replace = TRUE)%>%select(subject_id)
  
  group2ids <- ratings_df %>%
  # filter(!subject_id %in% group1ids$subject_id) %>%
  group_by(condition_num) %>%
  sample_n(sample_size, replace = TRUE) %>%
  select(subject_id)
  
  group1df<-ratings_df%>%filter(subject_id%in%group1ids$subject_id)
  group2df<-ratings_df%>%filter(subject_id%in%group2ids$subject_id)
  
  group1mat<- group1df%>% group_by(texture, concept) %>%summarise(mean_rating = mean(response),.groups='keep')%>%
  pivot_wider(names_from = texture, values_from = mean_rating)
  group2mat<- group2df%>% group_by(texture, concept) %>%summarise(mean_rating = mean(response),.groups='keep')%>%
  pivot_wider(names_from = texture, values_from = mean_rating)
  
  concept_names <- group1mat$concept # Preserve concept names in correct order for later
  
  group1mat <- group1mat[order(group1mat$concept), -1]  # Remove concept column
  group2mat <- group2mat[order(group2mat$concept), -1]  # Remove concept column
  
  common_columns <- intersect(colnames(group1mat), colnames(group2mat))  # Find common columns
  group1mat <- group1mat[, sort(common_columns)]
  group2mat <- group2mat[, sort(common_columns)]
  
  ### @Anna lol could you just change things below so that we compute concept-wise correlations and return a dataframe of correlations for each concept
  
  ### @Kushin lol yes. I changed things so that the function returns a list with both the mean_correlation and the correlation_df (the correlation_df specifies the correlation value for each concept)
  
  rowwise_correlations <- mapply(function(row1, row2) {
    cor(row1, row2, use = "pairwise.complete.obs")
  }, as.data.frame(t(group1mat)), as.data.frame(t(group2mat)))
  
  # Create dataframe of concept-wise correlations
  correlation_df <- data.frame(
    concept = concept_names,
    correlation = rowwise_correlations
  )
  
  # Compute mean correlation
  mean_correlation <- mean(rowwise_correlations, na.rm = TRUE)
  
  return(list(mean_correlation = mean_correlation, correlation_df = correlation_df))

  
}



```

```{r}
### @Kushin I updated the running code so that it works as before with the updated function 
iters<-numeric()
sample_sizes<-numeric()
mean_rs<-numeric()
correlation_dfs<-list()
for(iter in 1:100){
for(sample_size in seq(5, 50, by = 5)){
  result <- bootstrap_associations_matrices(ratings_trials_exp, sample_size)
  mean_rs <- rbind(mean_rs, result$mean_correlation)
  correlation_dfs[[length(correlation_dfs) + 1]] <- result$correlation_df
  iters<- rbind(iters, iter)
  sample_sizes<-rbind(sample_sizes, sample_size)

}
}


bootstrap_df <- data.frame(cbind( iters,sample_sizes,mean_rs
))
colnames(bootstrap_df)<- c('iteration','sample_size','mean_reliability')



# Summarize data to calculate mean and standard error for each sample_size
summary_results <-bootstrap_df %>%
    group_by(sample_size) %>%
    summarise(
        se_reliability = sd(mean_reliability, na.rm = TRUE) / sqrt(n()),
        mean_reliability = mean(mean_reliability, na.rm = TRUE),
       
    )

# Create ggplots
ggplot(summary_results, aes(x = sample_size, y = mean_reliability)) +
  geom_line(color = "blue") +
  geom_ribbon(aes(ymin = mean_reliability - se_reliability,
                  ymax = mean_reliability + se_reliability),
              alpha = 0.1, fill = "red") +
  labs(
    title = "Mean Reliability Across Sample Sizes",
    x = "Sample Size",
    y = "Mean Reliability"
  ) +
  theme_minimal()
```

```{r}
# Convert list of correlation_dfs to single data frame
concept_correlation_data <- do.call(rbind, correlation_dfs)

# Add sample sizes and iterations to the correlation data
concept_correlation_data$sample_size <- rep(seq(5, 50, by = 5), each = 100 * length(concept_groups$concept))
concept_correlation_data$iteration <- rep(1:100, times = length(seq(5, 50, by = 5)) * length(concept_groups$concept))

# Add condition_num
concept_correlation_data <- left_join(concept_correlation_data, concept_groups, by = "concept") %>% 
  arrange(condition_num)

# Summarize data for plotting: mean reliability and standard error per concept, condition_num, and sample_size
summary_concept_results <- concept_correlation_data %>%
  group_by(sample_size, condition_num, concept) %>%
  summarise(
    se_reliability = sd(correlation, na.rm = TRUE) / sqrt(n()),
    mean_reliability = mean(correlation, na.rm = TRUE)
  )

# Plot
# Custom Colors
# Define your custom color palette
custom_colors <- c(
  "Concept1" = "#1f77b4",  # Blue
  "Concept2" = "#ff7f0e",  # Orange
  "Concept3" = "#2ca02c",  # Green
  "Concept4" = "#d62728",  # Red
  "Concept5" = "#9467bd"   # Purple
)

#ggplot
ggplot(summary_concept_results, aes(x = sample_size, y = mean_reliability, color = concept)) +
  geom_line() +
  geom_ribbon(aes(ymin = mean_reliability - se_reliability, ymax = mean_reliability + se_reliability, group = concept),
              alpha = 0.1, fill = "red", color = NA) +
  geom_text(
    data = summary_concept_results %>%
      group_by(condition_num, concept) %>%
      filter(sample_size == max(sample_size)), # Place label at the largest sample size
    aes(
      x = sample_size,
      y = mean_reliability,
      label = concept
    ),
    hjust = -0.1, # Slightly offset the labels horizontally
    vjust = 0, # Adjust vertical spacing
    size = 3,
    inherit.aes = FALSE # Avoid inheriting other plot aesthetics
  ) +
  labs(
    title = "Mean Reliability Across Sample Sizes for Each Concept and Condition",
    x = "Sample Size",
    y = "Mean Reliability"
  ) +
  theme_minimal() +
  facet_wrap(~ condition_num, ncol = 7) + 
  theme(
    legend.position = "none",
    plot.margin = margin(50, 50, 50, 50),
    panel.spacing = unit(3, "lines")) +
  #scale_color_manual(values = custom_colors) +
  coord_cartesian(clip = "off")
```
